# .github/workflows/deploy.yml
name: "Unified Deploy: CiCd + Blog (Intelligent & Ordered)"

on:
  push:
    branches: [main]
    paths:
      - "apps/frontend/**"
      - "apps/backend/**"
      - "apps/infra/lib/blog-stack.ts"
      - "apps/infra/lib/cicd-stack.ts"
      - "apps/infra/bin/infra.ts"
      - ".github/workflows/deploy.yml"
      - "pnpm-lock.yaml"
      - "scripts/setup_runner.sh"
  workflow_dispatch:

concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: true

env:
  AWS_REGION: ${{ secrets.AWS_REGION }}
  ECR_REPOSITORY: new-blog-frontend

jobs:
  detect_changes:
    name: "Detect Changed Paths"
    runs-on: ubuntu-latest
    outputs:
      blog: ${{ steps.paths.outputs.blog }}
      cicd: ${{ steps.paths.outputs.cicd }}
    steps:
      - name: "Checkout code"
        uses: actions/checkout@v4

      - name: "Filter changed paths"
        id: paths
        uses: dorny/paths-filter@v3
        with:
          filters: |
            blog:
              - 'apps/frontend/**'
              - 'apps/backend/**'
              - 'apps/infra/lib/blog-stack.ts'
              - 'pnpm-lock.yaml'
            cicd:
              - 'apps/infra/lib/cicd-stack.ts'
              - 'scripts/setup_runner.sh'
              - '.github/workflows/deploy.yml'

  deploy_cicd_infra:
    name: "Deploy CI/CD Infrastructure (CiCdStack)"
    needs: detect_changes
    if: ${{ needs.detect_changes.outputs.cicd == 'true' || github.event_name == 'workflow_dispatch' }}
    runs-on: ubuntu-latest
    permissions:
      id-token: write
      contents: read
    steps:
      - name: "Checkout code"
        uses: actions/checkout@v4
        with:
          fetch-depth: 2

      - name: Cache pnpm store and turborepo
        uses: actions/cache@v4
        with:
          path: |
            ~/.pnpm-store
            node_modules
            .turbo
          key: ${{ runner.os }}-pnpm-${{ hashFiles('**/pnpm-lock.yaml') }}-${{ hashFiles('**/package.json') }}
          restore-keys: |
            ${{ runner.os }}-pnpm-

      - name: "Setup Node.js & pnpm"
        uses: actions/setup-node@v4
        with:
          node-version: "22"
      - uses: pnpm/action-setup@v4

      - name: Install dependencies (pnpm with store)
        run: |
          export PNPM_STORE_PATH="${HOME}/.pnpm-store"
          mkdir -p "${PNPM_STORE_PATH}"
          pnpm install --frozen-lockfile --store-dir "${PNPM_STORE_PATH}"

      # ... (필요한 ci/cicd infra 배포 스텝들)
      # (원래 있는 스텝들을 그대로 두되, 실제 infra 배포 스텝은 여기에 추가하세요.)

  build_and_deploy:
    name: "Build once, push image, deploy infra, sync assets"
    needs: [detect_changes, deploy_cicd_infra]
    runs-on: self-hosted
    if: |
      always() &&
      (needs.detect_changes.outputs.blog == 'true' || github.event_name == 'workflow_dispatch')
    permissions:
      id-token: write
      contents: read
      packages: write
    steps:
      - name: "Checkout code"
        uses: actions/checkout@v4
        with:
          fetch-depth: 2

      - name: Prepare workspace pnpm store dir (ensure perms)
        run: |
          mkdir -p "${GITHUB_WORKSPACE}/.pnpm-store"
          chmod -R 0775 "${GITHUB_WORKSPACE}/.pnpm-store"

      - name: Cache pnpm store and turborepo (workspace-based)
        uses: actions/cache@v4
        with:
          path: |
            ${{ github.workspace }}/.pnpm-store
            ${{ github.workspace }}/.turbo
          key: ${{ runner.os }}-pnpm-${{ hashFiles('pnpm-lock.yaml') }}
          restore-keys: |
            ${{ runner.os }}-pnpm-

      - name: "Setup Node.js & pnpm"
        uses: actions/setup-node@v4
        with:
          node-version: "22"
      - uses: pnpm/action-setup@v4

      - name: Install dependencies (pnpm with workspace store)
        run: |
          export PNPM_STORE_PATH="${GITHUB_WORKSPACE}/.pnpm-store"
          mkdir -p "${PNPM_STORE_PATH}"
          pnpm install --frozen-lockfile --store-dir "${PNPM_STORE_PATH}"

      # -----------------------------
      # Build once: produce .next (single source)
      # -----------------------------
      - name: "Create RELEASE_ID"
        id: set_release
        run: |
          RELEASE_ID="$(date +%Y%m%d%H%M%S)-${GITHUB_SHA::7}"
          echo "release_id=$RELEASE_ID" >> $GITHUB_OUTPUT
          echo "Created release_id=$RELEASE_ID"

      - name: "Build frontend (single build)"
        run: |
          # 빌드는 오직 이곳에서만 실행됩니다.
          cd apps/frontend
          pnpm --filter frontend run build
        env:
          # 필요 시 빌드 환경변수 지정 (예: region 등)
          NODE_ENV: production

      # -----------------------------
      # AWS credentials & ECR login
      # -----------------------------
      - name: "Configure AWS Credentials (from EC2 Role)"
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-region: ${{ env.AWS_REGION }}

      - name: "Login to Amazon ECR"
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v2

      # -----------------------------
      # Build & Push Docker image (uses the .next built above in repo)
      # -----------------------------
      - name: "Build and push Docker image (re-uses built .next)"
        uses: docker/build-push-action@v5
        with:
          context: .
          file: ./apps/frontend/Dockerfile
          push: true
          tags: ${{ steps.login-ecr.outputs.registry }}/${{ env.ECR_REPOSITORY }}:${{ steps.set_release.outputs.release_id }}
          platforms: linux/arm64
          provenance: false

      # -----------------------------
      # Deploy infra (CDK) with ImageTag = release id
      # -----------------------------
      - name: "Deploy Blog Infrastructure (BlogInfraStack) via CDK"
        run: |
          pnpm --filter infra exec cdk deploy BlogInfraStack \
            --require-approval never \
            --outputs-file "${{ github.workspace }}/apps/infra/outputs.json" \
            --parameters ImageTag=${{ steps.set_release.outputs.release_id }}
        env:
          AWS_REGION: ${{ env.AWS_REGION }}

      # -----------------------------
      # Sync built static assets to S3 (same .next used in Docker build)
      # -----------------------------
      - name: "Sync Static Assets to S3 (single-build .next)"
        run: |
          set -euo pipefail
          ASSET_JSON_PATH="${{ github.workspace }}/apps/infra/outputs.json"
          if [ ! -f "$ASSET_JSON_PATH" ]; then
            echo "::error::CDK output file not found at $ASSET_JSON_PATH"
            exit 1
          fi
          ASSET_BUCKET_NAME=$(node -p "require('$ASSET_JSON_PATH').BlogInfraStack.FrontendAssetsBucketName")
          echo "Syncing ./apps/frontend/.next/static -> s3://${ASSET_BUCKET_NAME}/_next/static"
          aws s3 sync ./apps/frontend/.next/static s3://${ASSET_BUCKET_NAME}/_next/static --delete
        env:
          AWS_REGION: ${{ env.AWS_REGION }}

      # -----------------------------
      # Invalidate CloudFront cache (optional / narrow path)
      # -----------------------------
      - name: "Invalidate CloudFront Cache (narrow path)"
        run: |
          set -euo pipefail
          ASSET_JSON_PATH="${{ github.workspace }}/apps/infra/outputs.json"
          DISTRIBUTION_ID=$(node -p "require('$ASSET_JSON_PATH').BlogInfraStack.CloudFrontDistributionId")
          echo "Creating CloudFront invalidation for distribution ${DISTRIBUTION_ID}"
          aws cloudfront create-invalidation --distribution-id ${DISTRIBUTION_ID} --paths "/_next/static/*"
        env:
          AWS_REGION: ${{ env.AWS_REGION }}

      # -----------------------------
      # Smoke tests
      # -----------------------------
      - name: "Smoke test - check home page and sample static asset"
        run: |
          set -euo pipefail
          URL="https://blog.jungyu.store"
          echo "Checking ${URL}"
          HTTP_STATUS=$(curl -s -o /dev/null -w "%{http_code}" "$URL")
          if [ "$HTTP_STATUS" -ne 200 ]; then
            echo "Home page returned $HTTP_STATUS"
            exit 1
          fi

          # Check one static asset referenced by HTML
          ASSET=$(curl -sS "$URL" | grep -oP '_next/static[^"]+' | head -n 1)
          if [ -z "$ASSET" ]; then
            echo "No asset found in HTML"
            exit 2
          fi
          # HEAD check through CloudFront endpoint
          STATUS=$(curl -I -s -o /dev/null -w "%{http_code}" "https://blog.jungyu.store/${ASSET#_/}")
          echo "Sample asset HEAD status: $STATUS"
          if [ "$STATUS" -ne 200 ]; then
            echo "Sample asset not 200 -> $STATUS"
            exit 3
          fi
        env:
          AWS_REGION: ${{ env.AWS_REGION }}
