name: "Unified Deploy: CiCd + Blog (Optimized & Corrected)"

on:
  push:
    branches: [main]
    paths:
      - 'apps/**'
      - 'scripts/**'
      - '.github/workflows/deploy.yml'
      - 'pnpm-lock.yaml'
  workflow_dispatch:

concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: true

env:
  AWS_REGION: ${{ secrets.AWS_REGION }}
  ECR_REPOSITORY: new-blog-frontend

jobs:
  # ===================================================================================
  # JOB 1: 변경 감지
  # ===================================================================================
  detect_changes:
    name: "Detect Changed Paths"
    runs-on: ubuntu-latest
    outputs:
      blog: ${{ steps.paths.outputs.blog }}
      cicd: ${{ steps.paths.outputs.cicd }}
    steps:
      - name: "Checkout code"
        uses: actions/checkout@v4

      - name: "Filter changed paths"
        id: paths
        uses: dorny/paths-filter@v3
        with:
          filters: |
            blog:
              - 'apps/frontend/**'
              - 'apps/backend/**'
              - 'apps/infra/lib/blog-stack.ts'
              - 'pnpm-lock.yaml'
            cicd:
              - 'apps/infra/lib/cicd-stack.ts'
              - 'scripts/setup_runner.sh'

  # ===================================================================================
  # JOB 2: CI/CD 인프라 배포
  # ===================================================================================
  deploy_cicd_infra:
    name: "Deploy CI/CD Infrastructure (CiCdStack)"
    needs: detect_changes
    if: ${{ needs.detect_changes.outputs.cicd == 'true' || github.event_name == 'workflow_dispatch' }}
    runs-on: ubuntu-latest
    permissions:
      id-token: write
      contents: read
    steps:
      - name: "Checkout code"
        uses: actions/checkout@v4

      - name: "Setup Node.js & pnpm"
        uses: actions/setup-node@v4
        with:
          node-version: "22"
      - uses: pnpm/action-setup@v4

      - name: "Configure AWS Credentials"
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_ROLE_TO_ASSUME }}
          aws-region: ${{ env.AWS_REGION }}

      - name: "Deploy CiCdStack via CDK"
        run: |
          pnpm --filter infra install --frozen-lockfile
          pnpm --filter infra exec cdk deploy CiCdStack --require-approval never

  # ===================================================================================
  # JOB 3: 블로그 애플리케이션 배포 (Host-build 안전 모드 포함)
  # - 기본 동작: 안전하게 '호스트에서 빌드' 후 Dockerfile.prod로 패키징
  # - 안전장치: 호스트 빌드가 불가능/원치 않을 경우 기존 multi-stage Docker 빌드(기존 방식)로 자동 폴백
  # - 제어 플래그: USE_HOST_BUILD (기본 true). false로 설정하면 항상 기존 방식으로 동작합니다.
  # ===================================================================================
  deploy_blog_app:
    name: "Build and Deploy Blog Application (Multi-mode, safe)"
    needs: [detect_changes, deploy_cicd_infra]
    runs-on: self-hosted
    permissions:
      id-token: write
      contents: read
      packages: write
    if: |
      always() &&
      (needs.detect_changes.outputs.blog == 'true' || github.event_name == 'workflow_dispatch')
    env:
      # 기본값: 'true' 로 호스트 빌드를 사용합니다. 문제가 있으면 'false'로 설정하여 기존 방식으로 되돌릴 수 있습니다.
      USE_HOST_BUILD: 'true'
    steps:
      - name: "Checkout code"
        uses: actions/checkout@v4

      - name: "Configure AWS Credentials (from EC2 Role)"
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-region: ${{ env.AWS_REGION }}

      - name: "Login to Amazon ECR"
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v2

      - name: "Set up Docker Buildx"
        uses: docker/setup-buildx-action@v3

      - name: "Define Image Tag"
        id: image-def
        run: echo "TAG=$(date +%Y%m%d%H%M%S)-$(echo $GITHUB_SHA | cut -c1-7)" >> $GITHUB_OUTPUT

      # ------------------------
      # Node / pnpm 설치는 호스트 빌드를 위해 필요합니다.
      # ------------------------
      - name: "Setup Node.js & pnpm"
        uses: actions/setup-node@v4
        with:
          node-version: "22"
      - uses: pnpm/action-setup@v4

      - name: "Install repository dependencies (pnpm install)"
        run: |
          set -euo pipefail
          echo "Running pnpm install --frozen-lockfile at repository root..."
          pnpm install --frozen-lockfile

      # ------------------------
      # (선택) 호스트에서 frontend 빌드 — 안전 모드: 기본 true
      # - 성공적으로 빌드 산출물이 생성되면 Dockerfile.prod 경로로 이미지 빌드
      # - 산출물이 없으면 폴백으로 기존 Dockerfile 방식 사용
      # ------------------------
      - name: "Build frontend artifacts on runner (host-build)"
        if: env.USE_HOST_BUILD == 'true'
        run: |
          set -euo pipefail
          echo "호스트에서 frontend 빌드를 시도합니다..."
          # workspace 가 모노레포일 수 있으므로 frontend만 필터로 빌드
          pnpm --filter frontend run build
          echo "빌드 완료. 아래는 산출물 목록입니다(간단 확인)"
          ls -la apps/frontend/.next || true
          ls -la apps/frontend/standalone || true
          ls -la apps/frontend/public || true

      - name: "Check built artifacts presence"
        id: check_artifacts
        run: |
          set -euo pipefail
          # 호스트 빌드 또는 다른 방법으로 산출물이 있는지 확인
          if [ -d ./apps/frontend/standalone ] || [ -d ./apps/frontend/.next ]; then
            echo "exists=true" >> $GITHUB_OUTPUT
          else
            echo "exists=false" >> $GITHUB_OUTPUT
          fi

      # ------------------------
      # Prepare artifacts: Docker 컨텍스트가 기대하는 경로(standalone 등)로 산출물 준비
      # ------------------------
      - name: "Prepare artifacts for Docker context (ensure standalone present)"
        if: steps.check_artifacts.outputs.exists == 'true' && env.USE_HOST_BUILD == 'true'
        run: |
          set -euo pipefail
          echo "Preparing frontend artifacts inside apps/frontend for Docker context..."
          cd apps/frontend

          # If Next.js outputs .next/standalone, copy it to ./standalone so Dockerfile.prod COPY works.
          if [ -d ".next/standalone" ]; then
            echo "Found .next/standalone — copying to ./standalone (overwriting if exists)..."
            rm -rf ./standalone || true
            cp -a .next/standalone ./standalone
          fi

          # If .next/static exists, ensure it's present (we keep it under .next/static)
          if [ -d ".next/static" ]; then
            echo ".next/static exists (ok)."
          else
            echo "::warning:: .next/static not found — check build outputs."
          fi

          # public should be present already; warn if missing
          if [ -d "public" ]; then
            echo "public exists."
          else
            echo "::warning:: public directory not found."
          fi

          # list to help debugging
          echo "Prepared contents:"
          ls -la || true

      # ------------------------
      # 경로 A: 호스트 빌드 성공 시 (권장)
      # ------------------------
      - name: "Build & push image from pre-built artifacts (Dockerfile.prod)"
        if: steps.check_artifacts.outputs.exists == 'true' && env.USE_HOST_BUILD == 'true'
        uses: docker/build-push-action@v5
        with:
          context: ./apps/frontend
          file: ./apps/frontend/Dockerfile.prod
          push: true
          tags: ${{ steps.login-ecr.outputs.registry }}/${{ env.ECR_REPOSITORY }}:${{ steps.image-def.outputs.TAG }}
          platforms: linux/arm64
          provenance: false
          cache-from: type=registry,ref=${{ steps.login-ecr.outputs.registry }}/${{ env.ECR_REPOSITORY }}:cache
          cache-to: type=registry,ref=${{ steps.login-ecr.outputs.registry }}/${{ env.ECR_REPOSITORY }}:cache,mode=max,compression=zstd
          build-args: |
            STANDALONE_DIR=standalone
            PUBLIC_DIR=public
            STATIC_DIR=.next/static

      # ------------------------
      # 경로 B: 호스트 빌드를 사용하지 않거나(또는 산출물이 없을 때)
      # 기존 방식(원본 Dockerfile multi-stage)으로 빌드 — 안전한 폴백
      # ------------------------
      - name: "Build and push Docker image (multi-stage fallback)"
        if: steps.check_artifacts.outputs.exists != 'true' || env.USE_HOST_BUILD == 'false'
        uses: docker/build-push-action@v5
        with:
          context: .
          file: ./apps/frontend/Dockerfile
          push: true
          tags: ${{ steps.login-ecr.outputs.registry }}/${{ env.ECR_REPOSITORY }}:${{ steps.image-def.outputs.TAG }}
          platforms: linux/arm64
          provenance: false
          cache-from: type=registry,ref=${{ steps.login-ecr.outputs.registry }}/${{ env.ECR_REPOSITORY }}:cache
          cache-to: type=registry,ref=${{ steps.login-ecr.outputs.registry }}/${{ env.ECR_REPOSITORY }}:cache,mode=max,compression=zstd

      # ------------------------
      # 만약 폴백(기존 Docker 내부 빌드)이 사용되었다면, S3 싱크를 위해 이미지에서 산출물을 추출
      # (호스트 빌드 경로를 사용하면 이 단계는 스킵됨)
      # ------------------------
      - name: "Extract frontend assets from image (fallback extraction)"
        if: steps.check_artifacts.outputs.exists != 'true' || env.USE_HOST_BUILD == 'false'
        run: |
          set -euo pipefail
          IMAGE="${{ steps.login-ecr.outputs.registry }}/${{ env.ECR_REPOSITORY }}:${{ steps.image-def.outputs.TAG }}"
          echo "Fallback extraction: pulling image $IMAGE"
          docker pull "$IMAGE"

          EXTRACT_NAME="extract-frontend-${{ steps.image-def.outputs.TAG }}"
          TMP_OUT="./_extracted_frontend"
          rm -rf "$TMP_OUT"
          mkdir -p "$TMP_OUT"

          CID=$(docker create --name "$EXTRACT_NAME" "$IMAGE")
          echo "Created container $CID for extraction"

          docker cp "${CID}:/app/.next" "$TMP_OUT/.next" || true
          docker cp "${CID}:/app/public" "$TMP_OUT/public" || true
          docker cp "${CID}:/app/standalone" "$TMP_OUT/standalone" || true

          docker rm -f "$CID" >/dev/null || true

          mkdir -p ./apps/frontend
          rm -rf ./apps/frontend/.next || true
          mv "$TMP_OUT/.next" ./apps/frontend/.next || true

          rm -rf ./apps/frontend/public || true
          mv "$TMP_OUT/public" ./apps/frontend/public || true

          rm -rf ./apps/frontend/.next/standalone || true
          mv "$TMP_OUT/standalone" ./apps/frontend/.next/standalone || true

          echo "Extraction complete. Sizes:" 
          du -sh ./apps/frontend/.next || true
          du -sh ./apps/frontend/public || true

      # ------------------------
      # Deploy infra (CDK) — 기존과 동일 (ImageTag 파라미터 전달)
      # ------------------------
      - name: "Deploy Blog Infrastructure (BlogInfraStack)"
        run: |
          set -euo pipefail
          pnpm --filter infra install --frozen-lockfile
          pnpm --filter infra exec cdk deploy BlogInfraStack \
            --require-approval never \
            --outputs-file "${{ github.workspace }}/apps/infra/outputs.json" \
            --parameters ImageTag=${{ steps.image-def.outputs.TAG }}

      - name: "Sync Static Assets to S3"
        run: |
          set -euo pipefail
          ASSET_JSON_PATH="${{ github.workspace }}/apps/infra/outputs.json"
          if [ ! -f "$ASSET_JSON_PATH" ]; then
            echo "::error::CDK output file not found at $ASSET_JSON_PATH"
            exit 1
          fi
          ASSET_BUCKET_NAME=$(node -p "require('$ASSET_JSON_PATH').BlogInfraStack.FrontendAssetsBucketName")
          echo "Syncing ./apps/frontend/.next/static -> s3://${ASSET_BUCKET_NAME}/_next/static"
          aws s3 sync ./apps/frontend/.next/static "s3://${ASSET_BUCKET_NAME}/_next/static" --delete
          echo "Syncing ./apps/frontend/public -> s3://${ASSET_BUCKET_NAME}/public"
          aws s3 sync ./apps/frontend/public "s3://${ASSET_BUCKET_NAME}/public" --delete

      - name: "Invalidate CloudFront Cache"
        run: |
          set -euo pipefail
          ASSET_JSON_PATH="${{ github.workspace }}/apps/infra/outputs.json"
          if [ ! -f "$ASSET_JSON_PATH" ]; then
            echo "::error::CDK output file not found at $ASSET_JSON_PATH"
            exit 1
          fi
          DISTRIBUTION_ID=$(node -p "require('$ASSET_JSON_PATH').BlogInfraStack.CloudFrontDistributionId")
          echo "Creating CloudFront invalidation for distribution ${DISTRIBUTION_ID}"
          aws cloudfront create-invalidation --distribution-id ${DISTRIBUTION_ID} --paths "/*"
