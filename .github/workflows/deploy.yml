# ÌååÏùº ÏúÑÏπò: .github/workflows/deploy.yml
# Î≤ÑÏ†Ñ: v2025.09.13
# Ïó≠Ìï†: "Îã®Ïùº ÎπåÎìú, Îã§Ï§ë Î∞∞Ìè¨" ÏõêÏπôÏóê ÏûÖÍ∞ÅÌïòÏó¨, ÎπåÎìú Î∂àÏùºÏπòÏôÄ Ï∫êÏãú Î¨∏Ï†úÎ•º ÏõêÏ≤úÏ†ÅÏúºÎ°ú Ìï¥Í≤∞ÌïòÍ≥†,
#       YAML Î¨∏Î≤ï Ïò§Î•òÎ•º ÏôÑÎ≤ΩÌïòÍ≤å ÏàòÏ†ïÌïú ÏµúÏ¢Ö ÏïàÏ†ïÌôî Î≤ÑÏ†ÑÏùò ÌÜµÌï© Î∞∞Ìè¨ ÏõåÌÅ¨ÌîåÎ°úÏö∞.

name: "Unified Deploy: CiCd + Blog (Immutable Masterpiece)"

on:
  push:
    branches: [main]
    paths:
      - "apps/frontend/**"
      - "apps/backend/**"
      - "apps/infra/lib/blog-stack.ts"
      - "apps/infra/lib/cicd-stack.ts"
      - "apps/infra/bin/infra.ts"
      - ".github/workflows/deploy.yml"
      - "pnpm-lock.yaml"
      - "scripts/setup_runner.sh"
  workflow_dispatch:

concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: true

env:
  AWS_REGION: ${{ secrets.AWS_REGION }}
  ECR_REPOSITORY: new-blog-frontend

jobs:
  # ===================================================================================
  # JOB 1: Î≥ÄÍ≤Ω Í∞êÏßÄ (Í∏∞Ï°¥ Íµ¨Ï°∞ Ïú†ÏßÄ)
  # ===================================================================================
  detect_changes:
    name: "Detect Changed Paths"
    runs-on: ubuntu-latest
    outputs:
      blog: ${{ steps.paths.outputs.blog }}
      cicd: ${{ steps.paths.outputs.cicd }}
    steps:
      - name: "Checkout code"
        uses: actions/checkout@v4
      - name: "Filter changed paths"
        id: paths
        uses: dorny/paths-filter@v3
        with:
          filters: |
            blog:
              - 'apps/frontend/**'
              - 'apps/backend/**'
              - 'apps/infra/lib/blog-stack.ts'
              - 'pnpm-lock.yaml'
            cicd:
              - 'apps/infra/lib/cicd-stack.ts'
              - 'scripts/setup_runner.sh'
              - '.github/workflows/deploy.yml'

  # ===================================================================================
  # JOB 2: CI/CD Ïù∏ÌîÑÎùº Î∞∞Ìè¨ (Í∏∞Ï°¥ Íµ¨Ï°∞ Ïú†ÏßÄ)
  # ===================================================================================
  deploy_cicd_infra:
    name: "Deploy CI/CD Infrastructure (CiCdStack)"
    needs: detect_changes
    if: ${{ needs.detect_changes.outputs.cicd == 'true' || github.event_name == 'workflow_dispatch' }}
    runs-on: ubuntu-latest
    permissions: { id-token: write, contents: read }
    steps:
      - name: "Checkout code"
        uses: actions/checkout@v4
      - name: Cache pnpm store and turborepo
        uses: actions/cache@v4
        with:
          path: |
            ~/.pnpm-store
            node_modules
            .turbo
          key: ${{ runner.os }}-pnpm-${{ hashFiles('**/pnpm-lock.yaml') }}-${{ hashFiles('**/package.json') }}
          restore-keys: |
            ${{ runner.os }}-pnpm-
      - name: "Setup Node.js & pnpm"
        uses: actions/setup-node@v4
        with: { node-version: "22" }
      - uses: pnpm/action-setup@v4
      - name: Install dependencies (pnpm with store)
        run: |
          export PNPM_STORE_PATH="${HOME}/.pnpm-store"
          mkdir -p "${PNPM_STORE_PATH}"
          pnpm install --frozen-lockfile --store-dir "${PNPM_STORE_PATH}"
      # [TODO] Ïó¨Í∏∞Ïóê CiCdStackÏùÑ Î∞∞Ìè¨ÌïòÎäî cdk deploy Ïä§ÌÖùÏùÑ Ï∂îÍ∞ÄÌïòÏã≠ÏãúÏò§.

            # "Install dependencies" Ïä§ÌÖù Î∞îÎ°ú Îã§ÏùåÏóê Ï∂îÍ∞Ä
      - name: "Check network connectivity to Vercel"
        run: |
          echo "Pinging Vercel API endpoint..."
          curl -v https://api.vercel.com/v1/now/health

  # ===================================================================================
  # JOB 3: Î∏îÎ°úÍ∑∏ Ïï†ÌîåÎ¶¨ÏºÄÏù¥ÏÖò Î∞∞Ìè¨ (ÏôÑÎ≤ΩÌïòÍ≤å Ïû¨ÏÑ§Í≥Ñ Î∞è Í≤ÄÏ¶ùÎêú ÎßàÏä§ÌÑ∞ÌîºÏä§)
  # ===================================================================================
  build_and_deploy_blog_app:
    name: "Build, Test, and Deploy Blog Application"
    needs: [detect_changes, deploy_cicd_infra]
    runs-on: self-hosted
    if: |
      always() &&
      (needs.detect_changes.outputs.blog == 'true' || github.event_name == 'workflow_dispatch')
    permissions:
      id-token: write
      contents: read
      packages: write
    env:
      SENTRY_AUTH_TOKEN: ${{ secrets.SENTRY_AUTH_TOKEN }}
      SENTRY_ORG: 'deep-dive' # Sentry ÏÑ§Ï†ï > General Settings ÏóêÏÑú ÌôïÏù∏
      SENTRY_PROJECT: 'jungyu-blog-frontend'  
    steps:
      # --- 1ÏïÖÏû•: Ï§ÄÎπÑ (Setup) ---
      - name: "Checkout code"
        uses: actions/checkout@v4
        with: { fetch-depth: 0 }

      - name: Prepare workspace pnpm store dir
        run: |
          mkdir -p "${GITHUB_WORKSPACE}/.pnpm-store"
          chmod -R 0775 "${GITHUB_WORKSPACE}/.pnpm-store"

      - name: Cache pnpm store and turborepo
        uses: actions/cache@v4
        with:
          path: |
            ${{ github.workspace }}/.pnpm-store
            ${{ github.workspace }}/.turbo
          key: ${{ runner.os }}-pnpm-${{ hashFiles('pnpm-lock.yaml') }}
          restore-keys: |
            ${{ runner.os }}-pnpm-

      - name: "Setup Node.js & pnpm"
        uses: actions/setup-node@v4
        with: { node-version: "22" }
      - uses: pnpm/action-setup@v4

      - name: Install dependencies
        run: |
          export PNPM_STORE_PATH="${GITHUB_WORKSPACE}/.pnpm-store"
          mkdir -p "${PNPM_STORE_PATH}"
          pnpm install --frozen-lockfile --store-dir "${PNPM_STORE_PATH}"

      # --- 2ÏïÖÏû•: ÏßÄÌúò (The Single Build) ---
      - name: "Create Unique Release ID"
        id: set_release
        run: |
          RELEASE_ID="$(date +%Y%m%d%H%M%S)-${GITHUB_SHA::7}"
          echo "release_id=$RELEASE_ID" >> $GITHUB_OUTPUT
          echo "‚úÖ Created unique release ID: $RELEASE_ID"

      - name: "Configure AWS Credentials via OIDC"
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_ROLE_TO_ASSUME }} # GitHub SecretsÏóê Ï†ÄÏû•Îêú IAM Ïó≠Ìï† ARN
          aws-region: ${{ env.AWS_REGION }}    

      - name: "Read GitHub URL from Parameter Store"
        id: read_param
        run: |
          PARAM_NAME="/new-blog/frontend/github-url"
          VALUE=$(aws ssm get-parameter --name "$PARAM_NAME" --query "Parameter.Value" --output text)
          echo "GITHUB_URL_FROM_SSM=$VALUE" >> $GITHUB_ENV
          

      - name: "The Single Source of Truth: Build Frontend Once"
        env:
          NODE_ENV: production
          NEXT_PUBLIC_ASSET_PREFIX: "/${{ steps.set_release.outputs.release_id }}"
          NEXT_PUBLIC_RELEASE_ID: "${{ steps.set_release.outputs.release_id }}"
          NEXT_PUBLIC_API_ENDPOINT: /api
          NEXT_PUBLIC_GITHUB_URL: ${{ env.GITHUB_URL_FROM_SSM }}
          NEXT_PUBLIC_SENTRY_DSN: ${{ secrets.NEXT_PUBLIC_SENTRY_DSN }}
          SENTRY_RELEASE: ${{ steps.set_release.outputs.release_id }}

        run: |          
          echo "üöÄ Starting the single build..."
          pnpm --filter frontend run build

      - name: "Upload Sourcemaps to Sentry (in Background)"
        run: |
          echo "Installing @sentry/cli..."
          npm install -g @sentry/cli
          
          echo "Starting Sentry sourcemap upload in the background..."
          sentry-cli releases files ${{ env.SENTRY_RELEASE }} upload-sourcemaps ./apps/frontend/.next --org ${{ env.SENTRY_ORG }} --project ${{ env.SENTRY_PROJECT }} &
          
          echo "‚úÖ Sourcemap upload process has been started in the background."

      # --- Sentry Í≥µÏãù Ïï°ÏÖò ÎåÄÏã†, CLIÎ•º ÏßÅÏ†ë ÏÇ¨Ïö©ÌïòÏó¨ Î∞±Í∑∏ÎùºÏö¥ÎìúÏóêÏÑú Ïã§ÌñâÌï©ÎãàÎã§. ---
      - name: "Upload Sourcemaps to Sentry (in Background)"
        run: |
          echo "Installing @sentry/cli..."
          npm install -g @sentry/cli

          echo "Starting Sentry sourcemap upload in the background..."
          sentry-cli releases files ${{ env.SENTRY_RELEASE }} upload-sourcemaps ./apps/frontend/.next --org ${{ env.SENTRY_ORG }} --project ${{ env.SENTRY_PROJECT }} &

          echo "‚úÖ Sourcemap upload process has been started in the background."
          echo "CI/CD pipeline will now proceed to the next step without waiting for the upload to complete."         

      - name: "Build Sharp Lambda Layer Artifact"
        if: ${{ needs.detect_changes.outputs.blog == 'true' || needs.detect_changes.outputs.common == 'true' || github.event_name == 'workflow_dispatch' }}
        run: |
          echo "Building the sharp-layer.zip artifact on the runner..."
          chmod +x ./build-sharp-layer.sh
          ./build-sharp-layer.sh
        

      # --- 3ÏïÖÏû•: 2Ï§ëÏ£º (The Dual Deployment) ---
      - name: "Login to Amazon ECR"
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v2

      - name: "PART 1: Build & Push Production Image (Consumes .next)"
        id: build_image # [Ï∂îÍ∞Ä] Ïù¥ Ïä§ÌÖùÏóê idÎ•º Î∂ÄÏó¨ÌïòÏó¨ Ïù¥ÎØ∏ÏßÄ Ï†ïÎ≥¥Î•º Ï∞∏Ï°∞
        uses: docker/build-push-action@v5
        with:
          context: .
          file: ./apps/frontend/Dockerfile
          push: true
          tags: ${{ steps.login-ecr.outputs.registry }}/${{ env.ECR_REPOSITORY }}:${{ steps.set_release.outputs.release_id }}
          platforms: linux/arm64
          provenance: false
         
      - name: "Verify ECR Image Existence (Safety Check)"
        run: |
          echo "Verifying that the image was pushed successfully..."
          # aws ecr wait image-scan-complete ÎåÄÏã†, Ïù¥ÎØ∏ÏßÄ Ï°¥Ïû¨ ÏûêÏ≤¥Î•º ÌôïÏù∏ÌïòÎäî batch-get-imageÎ•º ÏÇ¨Ïö©Ìï©ÎãàÎã§.
          # Ïù¥ÎØ∏ÏßÄÍ∞Ä Ï°¥Ïû¨ÌïòÏßÄ ÏïäÏúºÎ©¥ Ïù¥ Î™ÖÎ†πÏñ¥Îäî ÏóêÎü¨Î•º ÎÇ¥Î©∞ Ïã§Ìå®ÌïòÍ≥†, ÌååÏù¥ÌîÑÎùºÏù∏ÏùÄ Ï¶âÏãú Ï§ëÎã®Îê©ÎãàÎã§.
          # --query "images[].imageId" > /dev/null Î∂ÄÎ∂ÑÏùÄ Î∂àÌïÑÏöîÌïú JSON Ï∂úÎ†•ÏùÑ Ïà®Í∏∞Í∏∞ ÏúÑÌï®ÏûÖÎãàÎã§.
          aws ecr batch-get-image --repository-name ${{ env.ECR_REPOSITORY }} --image-ids imageTag=${{ steps.set_release.outputs.release_id }} --query "images[].imageId" > /dev/null
          echo "‚úÖ ECR image verification successful. Proceeding with deployment."

      - name: "Deploy Infrastructure (Activates New Lambda Version)"
        id: cdk_deploy
        run: |
          pnpm --filter infra exec cdk deploy BlogInfraStack \
            --require-approval never \
            --outputs-file "${{ github.workspace }}/apps/infra/outputs.json" \
            --parameters ImageTag=${{ steps.set_release.outputs.release_id }}

      - name: "PART 2: Sync Static Assets to S3 (To Versioned Path)"
        run: |
          set -euo pipefail
          ASSET_JSON_PATH="${{ github.workspace }}/apps/infra/outputs.json"
          if [ ! -f "$ASSET_JSON_PATH" ]; then
            echo "::error::CDK output file not found at $ASSET_JSON_PATH"
            exit 1
          fi
          ASSET_BUCKET_NAME=$(node -p "require('$ASSET_JSON_PATH').BlogInfraStack.FrontendAssetsBucketName")
          echo "Syncing ./apps/frontend/.next/static -> s3://${ASSET_BUCKET_NAME}/${{ steps.set_release.outputs.release_id }}/_next/static"
          aws s3 sync ./apps/frontend/.next/static s3://${ASSET_BUCKET_NAME}/${{ steps.set_release.outputs.release_id }}/_next/static --delete

      # --- 4ÏïÖÏû•: ÌîºÎÇ†Î†à (Activation & Verification) ---
      - name: "Invalidate CloudFront Cache (For Root Paths Only)"
        run: |
          set -euo pipefail
          ASSET_JSON_PATH="${{ github.workspace }}/apps/infra/outputs.json"
          DISTRIBUTION_ID=$(node -p "require('$ASSET_JSON_PATH').BlogInfraStack.CloudFrontDistributionId")
          echo "Creating CloudFront invalidation for distribution ${DISTRIBUTION_ID} on path '/*'"
          aws cloudfront create-invalidation --distribution-id ${DISTRIBUTION_ID} --paths "/*"

      - name: "Smoke Test: Verify Deployment"
        run: |
          set -euo pipefail
          echo "Waiting 15 seconds for CloudFront to propagate..."
          sleep 15
          URL="https://blog.jungyu.store"
          echo "üî¨ [Test 1/2] Checking home page status at ${URL}"
          HTTP_STATUS=$(curl -s -o /dev/null -w "%{http_code}" "$URL")
          if [ "$HTTP_STATUS" -ne 200 ]; then
            echo "::error::Smoke test failed! Home page returned status ${HTTP_STATUS}"
            exit 1
          fi
          echo "‚úÖ Home page is accessible (Status: 200)."
          echo "üî¨ [Test 2/2] Checking for versioned static asset..."
          # [ÏïàÏ†ïÏÑ± Í∞úÏÑ†] curl Ï∂úÎ†•ÏùÑ ÌååÏùºÎ°ú Ï†ÄÏû•ÌïòÏó¨ Broken Pipe Î∞è Ïì∞Í∏∞ Ïò§Î•ò Î∞©ÏßÄ
          curl -sS -o smoke_test_index.html "$URL"
          ASSET_PATH=$(grep -m 1 -oP '/${{ steps.set_release.outputs.release_id }}/_next/static/[^"]+' smoke_test_index.html | head -n 1 || true)
          rm -f smoke_test_index.html

          if [ -z "$ASSET_PATH" ]; then
            echo "::error::Smoke test failed! Could not find a versioned asset path in the HTML source."
            curl -sS --fail "$URL" | head -n 30
            exit 2
          fi
          ASSET_URL="https://${URL#*//}${ASSET_PATH}"
          echo "Found versioned asset: ${ASSET_URL}"
          ASSET_STATUS=$(curl -s -o /dev/null -w "%{http_code}" "$ASSET_URL")
          if [ "$ASSET_STATUS" -ne 200 ]; then
            echo "::error::Smoke test failed! Versioned asset at ${ASSET_URL} returned status ${ASSET_STATUS}"
            exit 3
          fi
          echo "‚úÖ Versioned asset is accessible (Status: 200)."
          echo "üéâ Deployment successful and verified!"