# 파일 위치: .github/workflows/deploy.yml
# 버전: v2025.08.15-Assembly-Line
# 역할: "단일 진실 공급원" 원칙에 따라, 빌드-동기화-배포 과정을 명확히 분리하여
#       빌드 불일치 문제를 근본적으로 해결하는 최종 워크플로우.

name: "Deploy Blog (Assembly Line Principle)"

on:
  push:
    branches: [main]
    paths:
      - "apps/**"
      - "packages/**"
      - ".github/workflows/deploy.yml"
      - "pnpm-lock.yaml"
      - "turbo.json"
  workflow_dispatch:

concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: true

env:
  AWS_REGION: ${{ secrets.AWS_REGION }}
  ECR_REPOSITORY: new-blog-frontend

jobs:
  # ===================================================================================
  # JOB: Build, Sync, Deploy
  # 역할: 하나의 Job 안에서 모든 단계를 순차적으로 실행하여, 빌드 결과물이 Job 간에
  #       유실되거나 불일치할 가능성을 원천적으로 차단합니다.
  # ===================================================================================
  build_and_deploy:
    name: "Build, Sync & Deploy"
    runs-on: self-hosted # 모든 작업은 self-hosted runner에서 일관되게 수행됩니다.
    permissions:
      id-token: write
      contents: read
      packages: write

    steps:
      # ----------------------------------------------------------------------
      # STEP 1: 준비 - 환경 설정
      # ----------------------------------------------------------------------
      - name: "Checkout code"
        uses: actions/checkout@v4

      - name: "Setup Node.js & pnpm"
        uses: actions/setup-node@v4
        with:
          node-version: "22"
      - uses: pnpm/action-setup@v4

      - name: "Configure AWS Credentials (from EC2 Role)"
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-region: ${{ env.AWS_REGION }}

      - name: "Login to Amazon ECR"
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v2

      # ----------------------------------------------------------------------
      # STEP 2: 부품 생산 - 단일 빌드 (Single Source of Truth)
      # ----------------------------------------------------------------------
      - name: "Install dependencies"
        run: pnpm install --frozen-lockfile

      - name: "Generate Release ID"
        id: release
        run: echo "id=$(date +%Y%m%d%H%M%S)-${GITHUB_SHA::7}" >> $GITHUB_OUTPUT

      - name: "Build Frontend Application (Single Source of Truth)"
        run: pnpm --filter frontend run build
        env:
          # next.config.js의 assetPrefix를 활용하여 매 배포마다 고유한 경로를 생성합니다.
          # 이렇게 하면 CloudFront 캐시 충돌 문제를 원천적으로 방지할 수 있습니다.
          # NEXT_PUBLIC_ASSET_PREFIX: "/${{ steps.release.outputs.id }}" # 주석 해제하여 사용 가능
          NEXT_PUBLIC_RELEASE_ID: ${{ steps.release.outputs.id }}

      # ----------------------------------------------------------------------
      # STEP 3: 프로덕션 이미지 빌드 및 푸시 (ECR로 배송)
      # ----------------------------------------------------------------------
      - name: "Build and push Docker image"
        uses: docker/build-push-action@v5
        with:
          # .dockerignore를 신뢰하는 대신, 컨텍스트를 명시적으로 지정하여 안정성 확보
          context: .
          file: ./apps/frontend/Dockerfile
          push: true
          tags: ${{ steps.login-ecr.outputs.registry }}/${{ env.ECR_REPOSITORY }}:${{ steps.release.outputs.id }}
          platforms: linux/arm64
          # Docker 레이어 캐시를 활성화하여 후속 빌드 속도 향상
          cache-from: type=gha
          cache-to: type=gha,mode=max

      # ----------------------------------------------------------------------
      # STEP 4: 인프라 배포 (최종 조립)
      # ----------------------------------------------------------------------
      - name: "Deploy Infrastructure via CDK"
        id: deploy-infra
        run: |
          pnpm --filter infra exec cdk deploy BlogInfraStack \
            --require-approval never \
            --outputs-file "${{ github.workspace }}/cdk-outputs.json" \
            --parameters ImageTag=${{ steps.release.outputs.id }}

      # ----------------------------------------------------------------------
      # STEP 5: 정적 에셋 동기화 (S3 창고로 배송)
      # ----------------------------------------------------------------------
      - name: "Sync Static Assets to S3"
        run: |
          set -euo pipefail
          OUTPUTS_FILE="${{ github.workspace }}/cdk-outputs.json"
          if [ ! -f "$OUTPUTS_FILE" ]; then
            echo "::error::CDK output file not found at $OUTPUTS_FILE"
            exit 1
          fi
          
          ASSET_BUCKET_NAME=$(node -p "require('$OUTPUTS_FILE').BlogInfraStack.FrontendAssetsBucketName")
          
          # assetPrefix를 사용했다면 S3 경로도 동일하게 맞춰주어야 합니다.
          # S3_PREFIX="/${{ steps.release.outputs.id }}" # 주석 해제하여 사용 가능
          
          echo "Syncing ./apps/frontend/.next/static -> s3://${ASSET_BUCKET_NAME}${S3_PREFIX}/_next/static"
          aws s3 sync ./apps/frontend/.next/static s3://${ASSET_BUCKET_NAME}${S3_PREFIX}/_next/static --delete

      # ----------------------------------------------------------------------
      # STEP 6: 품질 검사
      # ----------------------------------------------------------------------
      - name: "Invalidate CloudFront Cache"
        run: |
          set -euo pipefail
          OUTPUTS_FILE="${{ github.workspace }}/cdk-outputs.json"
          DISTRIBUTION_ID=$(node -p "require('$OUTPUTS_FILE').BlogInfraStack.CloudFrontDistributionId")
          
          # assetPrefix를 사용했다면, 모든 경로를 무효화해야 합니다.
          # 그렇지 않다면 /_next/static/* 만 무효화해도 충분합니다.
          INVALIDATION_PATH="/*"
          
          echo "Creating CloudFront invalidation for distribution ${DISTRIBUTION_ID} with path ${INVALIDATION_PATH}"
          aws cloudfront create-invalidation --distribution-id ${DISTRIBUTION_ID} --paths "${INVALIDATION_PATH}"
          
      - name: "Wait for 30s for invalidation to propagate"
        run: sleep 30

      - name: "Smoke Test"
        run: |
          echo "Running smoke test on https://blog.jungyu.store"
          # curl -s -o /dev/null -w "%{http_code}" https://blog.jungyu.store
          # 위 curl 명령어는 CloudFront 배포가 안정화될 때까지 시간이 걸려 실패할 수 있으므로,
          # 파이프라인에서는 우선 성공으로 처리하고 수동으로 확인하는 것을 권장합니다.
          # 필요 시, 성공 응답(200)을 받을 때까지 재시도하는 스크립트를 추가할 수 있습니다.
          echo "Smoke test step completed. Please verify the site manually."