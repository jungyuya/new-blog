# 파일 위치: .github/workflows/deploy.yml
# 버전: v2025.08.12-Intelligent-Pipeline
# 역할: 코드 변경 사항을 감지하여, CI/CD 인프라와 블로그 애플리케이션의 배포를
#       독립적이고, 올바른 순서로, 그리고 조건부로 실행하는 최종 통합 워크플로우

name: "Unified Deploy: CiCd + Blog (Intelligent & Ordered)"

on:
  push:
    branches: [main]
    # 워크플로우가 트리거되는 파일 경로의 전체 집합
    paths:
      - "apps/frontend/**"
      - "apps/backend/**"
      - "apps/infra/lib/blog-stack.ts"
      - "apps/infra/lib/cicd-stack.ts"
      - "apps/infra/bin/infra.ts"
      - ".github/workflows/deploy.yml" # 자기 자신을 포함하여 워크플로우 변경 시에도 실행
      - "pnpm-lock.yaml"
      - "scripts/setup_runner.sh"
  workflow_dispatch:

concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: true

env:
  AWS_REGION: ${{ secrets.AWS_REGION }}
  ECR_REPOSITORY: new-blog-frontend

jobs:
  # ===================================================================================
  # JOB 1: 변경 감지
  # 역할: 어떤 코드가 변경되었는지 신속하게 판단하여, 후속 Job들의 실행 여부를 결정.
  # ===================================================================================
  detect_changes:
    name: "Detect Changed Paths"
    runs-on: ubuntu-latest
    outputs:
      blog: ${{ steps.paths.outputs.blog }}
      cicd: ${{ steps.paths.outputs.cicd }}
    steps:
      - name: "Checkout code"
        uses: actions/checkout@v4

      - name: "Filter changed paths"
        id: paths
        uses: dorny/paths-filter@v3 # 최신 버전 사용 권장
        with:
          filters: |
            blog:
              - 'apps/frontend/**'
              - 'apps/backend/**'
              - 'apps/infra/lib/blog-stack.ts'
              - 'pnpm-lock.yaml'
            cicd:
              - 'apps/infra/lib/cicd-stack.ts'
              - 'scripts/setup_runner.sh'
              - '.github/workflows/deploy.yml'

  # ===================================================================================
  # JOB 2: CI/CD 인프라 배포
  # 역할: Self-Hosted Runner(EC2)와 관련된 인프라를 배포.
  #       'cicd' 경로에 변경이 있거나, 수동 실행 시에만 트리거됨.
  # ===================================================================================
  deploy_cicd_infra:
    name: "Deploy CI/CD Infrastructure (CiCdStack)"
    needs: detect_changes
    # [핵심 수정] Job 레벨에서 실행 여부를 결정하여, 불필요한 실행을 원천 차단.
    if: ${{ needs.detect_changes.outputs.cicd == 'true' || github.event_name == 'workflow_dispatch' }}
    runs-on: ubuntu-latest
    permissions:
      id-token: write
      contents: read
    steps:
      - name: "Checkout code"
        uses: actions/checkout@v4
        with:
          fetch-depth: 2

      # -----------------------------
      # Step1: pnpm store / node_modules / .turbo 캐시
      # (checkout 직후에 추가)
      # -----------------------------
      - name: Cache pnpm store and turborepo
        uses: actions/cache@v4
        with:
          path: |
            ~/.pnpm-store
            node_modules
            .turbo
          key: ${{ runner.os }}-pnpm-${{ hashFiles('**/pnpm-lock.yaml') }}-${{ hashFiles('**/package.json') }}
          restore-keys: |
            ${{ runner.os }}-pnpm-

      - name: "Setup Node.js & pnpm"
        uses: actions/setup-node@v4
        with:
          node-version: "22"
      - uses: pnpm/action-setup@v4

      - name: Install dependencies (pnpm with store)
        run: |
          export PNPM_STORE_PATH="${HOME}/.pnpm-store"
          mkdir -p "${PNPM_STORE_PATH}"
          pnpm install --frozen-lockfile --store-dir "${PNPM_STORE_PATH}"

  # ===================================================================================
  # JOB 3: 블로그 애플리케이션 배포
  # 역할: 실제 블로그 애플리케이션을 빌드하고 배포. Self-Hosted Runner에서 실행.
  #       'blog' 경로에 변경이 있거나, 수동 실행 시에만 트리거됨.
  #       항상 CI/CD 인프라 배포가 끝난 후에 실행되어 안정성을 보장.
  # ===================================================================================
  deploy_blog_app:
    name: "Build and Deploy Blog Application"
    # [수정] needs는 그대로 유지합니다. 순서는 중요하기 때문입니다.
    needs: [detect_changes, deploy_cicd_infra]
    runs-on: self-hosted
    permissions:
      id-token: write
      contents: read
      packages: write
    # [최종 수정] if 조건문에 always()를 추가하여, 선행 Job의 결과와 상관없이
    # 이 Job의 실행 여부를 독립적으로 판단하도록 합니다.
    if: |
      always() &&
      (needs.detect_changes.outputs.blog == 'true' || github.event_name == 'workflow_dispatch')
    steps:
      - name: "Checkout code"
        uses: actions/checkout@v4
        with:
          fetch-depth: 2

      - name: Prepare workspace pnpm store dir (ensure perms)
        run: |
          mkdir -p "${GITHUB_WORKSPACE}/.pnpm-store"
          chmod -R 0775 "${GITHUB_WORKSPACE}/.pnpm-store"

      - name: Cache pnpm store and turborepo (workspace-based)
        uses: actions/cache@v4
        with:
          path: |
            ${{ github.workspace }}/.pnpm-store
            ${{ github.workspace }}/.turbo
          # Use top-level lockfile; if monorepo has pnpm-lock.yaml in root, use that exact path
          key: ${{ runner.os }}-pnpm-${{ hashFiles('pnpm-lock.yaml') }}
          restore-keys: |
            ${{ runner.os }}-pnpm-

      - name: "Setup Node.js & pnpm"
        uses: actions/setup-node@v4
        with:
          node-version: "22"
      - uses: pnpm/action-setup@v4

      - name: "Debug: env, pnpm and workspace .pnpm-store"
        run: |
          echo "---- ENV ----"
          echo "GITHUB_WORKSPACE=$GITHUB_WORKSPACE"
          echo "RUNNER_OS=${RUNNER_OS:-$RUNNER_OS}"
          echo "HOME=$HOME"
          echo "pwd: $(pwd)"
          echo "ls workspace root:"
          ls -la "${GITHUB_WORKSPACE}" | sed -n '1,200p'

          echo "---- Check pnpm version (if installed) ----"
          pnpm -v || echo "pnpm not found yet"

          echo "---- Check lockfile and package files ----"
          if [ -f "${GITHUB_WORKSPACE}/pnpm-lock.yaml" ]; then echo "Found root pnpm-lock.yaml"; else echo "No root pnpm-lock.yaml"; fi
          ls -la "${GITHUB_WORKSPACE}" | grep -E "pnpm-lock.yaml|package.json" || true

          echo "---- Check cached .pnpm-store dir if present ----"
          if [ -d "${GITHUB_WORKSPACE}/.pnpm-store" ]; then
            echo ">>> .pnpm-store exists"
            du -sh "${GITHUB_WORKSPACE}/.pnpm-store" || true
            ls -la "${GITHUB_WORKSPACE}/.pnpm-store" | sed -n '1,200p'
            echo "List top items in store:"
            find "${GITHUB_WORKSPACE}/.pnpm-store" -maxdepth 2 -type d -printf '%p %s\n' | sed -n '1,50p' || true
          else
            echo ">>> .pnpm-store does NOT exist in workspace"
          fi

          echo "---- Check home .pnpm-store (in case pnpm uses home) ----"
          if [ -d "${HOME}/.pnpm-store" ]; then
            echo ">>> HOME .pnpm-store exists"
            du -sh "${HOME}/.pnpm-store" || true
            ls -la "${HOME}/.pnpm-store" | sed -n '1,50p'
          else
            echo ">>> HOME .pnpm-store does NOT exist"
          fi

          echo "---- Check actions/cache UI hint ----"
          echo "After run, open Actions -> this run -> Caches (right side) and tell me whether cache was restored and the key shown."

          echo "---- End of debug ----"




      - name: Install dependencies (pnpm with workspace store)
        run: |
          export PNPM_STORE_PATH="${GITHUB_WORKSPACE}/.pnpm-store"
          mkdir -p "${PNPM_STORE_PATH}"
          pnpm install --frozen-lockfile --store-dir "${PNPM_STORE_PATH}"

      - name: "Build Applications with Turborepo"
        run: pnpm --filter frontend --filter backend run build

      - name: "Configure AWS Credentials (from EC2 Role)"
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-region: ${{ env.AWS_REGION }}

      - name: "Login to Amazon ECR"
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v2

      - name: "Build and push Docker image (with registry cache)"
        uses: docker/build-push-action@v5
        with:
          context: .
          file: ./apps/frontend/Dockerfile
          push: true
          tags: ${{ steps.login-ecr.outputs.registry }}/${{ env.ECR_REPOSITORY }}:${{ steps.image-def.outputs.TAG }}
          platforms: linux/arm64
          # registry 캐시: 읽기(from) / 쓰기(to)
          cache-from: type=registry,ref=${{ steps.login-ecr.outputs.registry }}/${{ env.ECR_REPOSITORY }}:cache
          cache-to: type=registry,ref=${{ steps.login-ecr.outputs.registry }}/${{ env.ECR_REPOSITORY }}:cache,mode=max
          provenance: false        

      - name: "Define Image Tag"
        id: image-def
        run: echo "TAG=$(date +%Y%m%d%H%M%S)-$(echo $GITHUB_SHA | cut-c1-7)" >> $GITHUB_OUTPUT

      - name: "Build and push Docker image"
        uses: docker/build-push-action@v5
        with:
          context: .
          file: ./apps/frontend/Dockerfile
          push: true
          tags: ${{ steps.login-ecr.outputs.registry }}/${{ env.ECR_REPOSITORY }}:${{ steps.image-def.outputs.TAG }}
          platforms: linux/arm64
          provenance: false

      - name: "Deploy Blog Infrastructure (BlogInfraStack)"
        run: |
          pnpm --filter infra exec cdk deploy BlogInfraStack \
            --require-approval never \
            --outputs-file "${{ github.workspace }}/apps/infra/outputs.json" \
            --parameters ImageTag=${{ steps.image-def.outputs.TAG }}

      - name: "Sync Static Assets to S3"
        run: |
          set -euo pipefail
          ASSET_JSON_PATH="${{ github.workspace }}/apps/infra/outputs.json"
          if [ ! -f "$ASSET_JSON_PATH" ]; then
            echo "::error::CDK output file not found at $ASSET_JSON_PATH"
            exit 1
          fi
          ASSET_BUCKET_NAME=$(node -p "require('$ASSET_JSON_PATH').BlogInfraStack.FrontendAssetsBucketName")
          echo "Syncing ./apps/frontend/.next/static -> s3://${ASSET_BUCKET_NAME}/_next/static"
          aws s3 sync ./apps/frontend/.next/static s3://${ASSET_BUCKET_NAME}/_next/static --delete

      - name: "Invalidate CloudFront Cache"
        run: |
          set -euo pipefail
          ASSET_JSON_PATH="${{ github.workspace }}/apps/infra/outputs.json"
          if [ ! -f "$ASSET_JSON_PATH" ]; then
            echo "::error::CDK output file not found at $ASSET_JSON_PATH"
            exit 1
          fi
          DISTRIBUTION_ID=$(node -p "require('$ASSET_JSON_PATH').BlogInfraStack.CloudFrontDistributionId")
          echo "Creating CloudFront invalidation for distribution ${DISTRIBUTION_ID}"
          aws cloudfront create-invalidation --distribution-id ${DISTRIBUTION_ID} --paths "/*"
